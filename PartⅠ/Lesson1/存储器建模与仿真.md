# 存储器建模与仿真

CPU 的运行离不开指令。在 CPU 中指令是存储在存储器中的二进制数据。CPU 按照指令处理的对象是各种数据，这些数据中很多来自数据数据存储器，并且最终存储在数据存储器中等待被使用。存储器是 CPU 模型中非常重要的一个部分。这篇文章目录下的所有文件都是研究 Verilog 中存储器的建模和仿真的内容。

### ROM 建模

Verilog HDL 中提供了二维数组来帮助我们建立内存的行为模型。我们可以使用一个 reg 类型的数组作为存储器，并且这个存储器的每一个单元都可以通过数组下标的方式进行访问。

内存（二维数组）的声明方式如下：

```verilog
reg [wordsize:0] array_name [0:arraysize];
```

这其中 `wordsize` 表示内存中数据的宽度，`arraysize` 表示内存的深度，也就是存储单元的数量。

对于一个 32 位的 CPU，我们应该设计内存中的数据宽度为 32 位，内存深度则是可选的。如果我们想要一个存储指令（32位指令）的指令存储器，并且我们需要存储的指令有 5 条，那么我们可以进行如下声明：

```verilog
reg [31:0] instr [0:4];
```

使用二维数组建立的内存行为模型既可以作为 ROM（只读存储器）使用也可以作为可读可写存储器使用。两者的主要区别在于是否使用控制信号来控制写入。

创建一个完整的内存 `module` 包括三个步骤：

1. 声明内存模型
2. 初始化内存内容
3. 根据输入的地址，得到对应地址的数据

下面讨论一下仿真中如何实现内容内容的初始化。内存可以分为只读存储器和可读可写存储器，前者的例子是 EEPOM，后者的例子是 SRAM。如果要仿真的对象是只读存储器，那么最好的方式是将数据放在一个文件中，使用系统任务 `$readmemb` 和 `$readmemh` 将数据从文件加载到我们的二维数组（内存行为模型）中。因为使用十六进制数描述指令码会比较方便，这里我们只讨论 `$readmemh` 的用法，`$readmemb` 的用法类似，只是操作的数字是二进制数字。

```verilog
$readmemh("file_name", mem_array, start_addr, stop_addr);
```

其中，`file_name` 是包含数据的文本文件名，`mem_array` 是要初始化的内存单元数组名，`start_addr` 和 `stop_addr` 是可选的，指示要初始化单元的起始地址和结束地址。

具体使用时，我们可以在 `module ` 的 `initial` 语句块中使用 `$readmemh`。`initial` 语句块作为一个不可综合的，只执行一次的语句块，既表明这个系统任务不是可综合的代码，也能一眼看出是用来初始化使用的代码。

```verilog
module memory;
    
    reg [7:0] memory [0:255];

    initial begin
        $readmemh("memory_data.txt", memory);
    end
    
endmodule
```

初始化后可以进行继续编写内存的基本操作，即根据输入的地址输出对应地址中的数据。给出地址后访问对应处的数据语法上十分简单：

```verilog
// 如果要存储一个值到某个单元中去，可以这样做：
memory [address] = data;

// 而如果要从某个单元读出值，可以这么做：
data = memory [address];
```

最后综合上述代码，写一个只读存储器代码。代码存放在 `...\PartⅠ\Lesson1\ROM` 目录中，在 [OSS CAD Suite] 环境下进入该目录，运行目录中的 `run.bat` 即可获得结果。可以增删 `memory_data.txt` 文件中的数据数量并查看编译结果。

### RWM 建模

### FPGA 中存储数据的方式

### CPU 中的数据对齐



### 